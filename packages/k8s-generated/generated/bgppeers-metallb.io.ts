// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * BGPPeer is the Schema for the peers API.
 *
 * @schema BGPPeer
 */
export class BgpPeer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BGPPeer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'metallb.io/v1beta1',
    kind: 'BGPPeer',
  }

  /**
   * Renders a Kubernetes manifest for "BGPPeer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BgpPeerProps = {}): any {
    return {
      ...BgpPeer.GVK,
      ...toJson_BgpPeerProps(props),
    };
  }

  /**
   * Defines a "BGPPeer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BgpPeerProps = {}) {
    super(scope, id, {
      ...BgpPeer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BgpPeer.GVK,
      ...toJson_BgpPeerProps(resolved),
    };
  }
}

/**
 * BGPPeer is the Schema for the peers API.
 *
 * @schema BGPPeer
 */
export interface BgpPeerProps {
  /**
   * @schema BGPPeer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BGPPeerSpec defines the desired state of Peer.
   *
   * @schema BGPPeer#spec
   */
  readonly spec?: BgpPeerSpec;

}

/**
 * Converts an object of type 'BgpPeerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerProps(obj: BgpPeerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BgpPeerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BGPPeerSpec defines the desired state of Peer.
 *
 * @schema BgpPeerSpec
 */
export interface BgpPeerSpec {
  /**
   * @schema BgpPeerSpec#bfdProfile
   */
  readonly bfdProfile?: string;

  /**
   * EBGP peer is multi-hops away
   *
   * @schema BgpPeerSpec#ebgpMultiHop
   */
  readonly ebgpMultiHop?: boolean;

  /**
   * Requested BGP hold time, per RFC4271.
   *
   * @schema BgpPeerSpec#holdTime
   */
  readonly holdTime?: string;

  /**
   * Requested BGP keepalive time, per RFC4271.
   *
   * @schema BgpPeerSpec#keepaliveTime
   */
  readonly keepaliveTime?: string;

  /**
   * AS number to use for the local end of the session.
   *
   * @schema BgpPeerSpec#myASN
   */
  readonly myAsn: number;

  /**
   * Only connect to this peer on nodes that match one of these selectors.
   *
   * @schema BgpPeerSpec#nodeSelectors
   */
  readonly nodeSelectors?: BgpPeerSpecNodeSelectors[];

  /**
   * Authentication password for routers enforcing TCP MD5 authenticated sessions
   *
   * @schema BgpPeerSpec#password
   */
  readonly password?: string;

  /**
   * AS number to expect from the remote end of the session.
   *
   * @schema BgpPeerSpec#peerASN
   */
  readonly peerAsn: number;

  /**
   * Address to dial when establishing the session.
   *
   * @schema BgpPeerSpec#peerAddress
   */
  readonly peerAddress: string;

  /**
   * Port to dial when establishing the session.
   *
   * @schema BgpPeerSpec#peerPort
   */
  readonly peerPort?: number;

  /**
   * BGP router ID to advertise to the peer
   *
   * @schema BgpPeerSpec#routerID
   */
  readonly routerId?: string;

  /**
   * Source address to use when establishing the session.
   *
   * @schema BgpPeerSpec#sourceAddress
   */
  readonly sourceAddress?: string;

}

/**
 * Converts an object of type 'BgpPeerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpec(obj: BgpPeerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bfdProfile': obj.bfdProfile,
    'ebgpMultiHop': obj.ebgpMultiHop,
    'holdTime': obj.holdTime,
    'keepaliveTime': obj.keepaliveTime,
    'myASN': obj.myAsn,
    'nodeSelectors': obj.nodeSelectors?.map(y => toJson_BgpPeerSpecNodeSelectors(y)),
    'password': obj.password,
    'peerASN': obj.peerAsn,
    'peerAddress': obj.peerAddress,
    'peerPort': obj.peerPort,
    'routerID': obj.routerId,
    'sourceAddress': obj.sourceAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BgpPeerSpecNodeSelectors
 */
export interface BgpPeerSpecNodeSelectors {
  /**
   * @schema BgpPeerSpecNodeSelectors#matchExpressions
   */
  readonly matchExpressions?: BgpPeerSpecNodeSelectorsMatchExpressions[];

  /**
   * @schema BgpPeerSpecNodeSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'BgpPeerSpecNodeSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpecNodeSelectors(obj: BgpPeerSpecNodeSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_BgpPeerSpecNodeSelectorsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BgpPeerSpecNodeSelectorsMatchExpressions
 */
export interface BgpPeerSpecNodeSelectorsMatchExpressions {
  /**
   * @schema BgpPeerSpecNodeSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * @schema BgpPeerSpecNodeSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * @schema BgpPeerSpecNodeSelectorsMatchExpressions#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'BgpPeerSpecNodeSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpecNodeSelectorsMatchExpressions(obj: BgpPeerSpecNodeSelectorsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * BGPPeer is the Schema for the peers API.
 *
 * @schema BGPPeerV1Beta2
 */
export class BgpPeerV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BGPPeerV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'metallb.io/v1beta2',
    kind: 'BGPPeer',
  }

  /**
   * Renders a Kubernetes manifest for "BGPPeerV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BgpPeerV1Beta2Props = {}): any {
    return {
      ...BgpPeerV1Beta2.GVK,
      ...toJson_BgpPeerV1Beta2Props(props),
    };
  }

  /**
   * Defines a "BGPPeerV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BgpPeerV1Beta2Props = {}) {
    super(scope, id, {
      ...BgpPeerV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BgpPeerV1Beta2.GVK,
      ...toJson_BgpPeerV1Beta2Props(resolved),
    };
  }
}

/**
 * BGPPeer is the Schema for the peers API.
 *
 * @schema BGPPeerV1Beta2
 */
export interface BgpPeerV1Beta2Props {
  /**
   * @schema BGPPeerV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BGPPeerSpec defines the desired state of Peer.
   *
   * @schema BGPPeerV1Beta2#spec
   */
  readonly spec?: BgpPeerV1Beta2Spec;

}

/**
 * Converts an object of type 'BgpPeerV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerV1Beta2Props(obj: BgpPeerV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BgpPeerV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BGPPeerSpec defines the desired state of Peer.
 *
 * @schema BgpPeerV1Beta2Spec
 */
export interface BgpPeerV1Beta2Spec {
  /**
   * The name of the BFD Profile to be used for the BFD session associated to the BGP session. If not set, the BFD session won't be set up.
   *
   * @schema BgpPeerV1Beta2Spec#bfdProfile
   */
  readonly bfdProfile?: string;

  /**
   * To set if the BGPPeer is multi-hops away. Needed for FRR mode only.
   *
   * @schema BgpPeerV1Beta2Spec#ebgpMultiHop
   */
  readonly ebgpMultiHop?: boolean;

  /**
   * Requested BGP hold time, per RFC4271.
   *
   * @schema BgpPeerV1Beta2Spec#holdTime
   */
  readonly holdTime?: string;

  /**
   * Requested BGP keepalive time, per RFC4271.
   *
   * @schema BgpPeerV1Beta2Spec#keepaliveTime
   */
  readonly keepaliveTime?: string;

  /**
   * AS number to use for the local end of the session.
   *
   * @schema BgpPeerV1Beta2Spec#myASN
   */
  readonly myAsn: number;

  /**
   * Only connect to this peer on nodes that match one of these selectors.
   *
   * @schema BgpPeerV1Beta2Spec#nodeSelectors
   */
  readonly nodeSelectors?: BgpPeerV1Beta2SpecNodeSelectors[];

  /**
   * Authentication password for routers enforcing TCP MD5 authenticated sessions
   *
   * @schema BgpPeerV1Beta2Spec#password
   */
  readonly password?: string;

  /**
   * passwordSecret is name of the authentication secret for BGP Peer. the secret must be of type "kubernetes.io/basic-auth", and created in the same namespace as the MetalLB deployment. The password is stored in the secret as the key "password".
   *
   * @schema BgpPeerV1Beta2Spec#passwordSecret
   */
  readonly passwordSecret?: BgpPeerV1Beta2SpecPasswordSecret;

  /**
   * AS number to expect from the remote end of the session.
   *
   * @schema BgpPeerV1Beta2Spec#peerASN
   */
  readonly peerAsn: number;

  /**
   * Address to dial when establishing the session.
   *
   * @schema BgpPeerV1Beta2Spec#peerAddress
   */
  readonly peerAddress: string;

  /**
   * Port to dial when establishing the session.
   *
   * @schema BgpPeerV1Beta2Spec#peerPort
   */
  readonly peerPort?: number;

  /**
   * BGP router ID to advertise to the peer
   *
   * @schema BgpPeerV1Beta2Spec#routerID
   */
  readonly routerId?: string;

  /**
   * Source address to use when establishing the session.
   *
   * @schema BgpPeerV1Beta2Spec#sourceAddress
   */
  readonly sourceAddress?: string;

  /**
   * To set if we want to peer with the BGPPeer using an interface belonging to a host vrf
   *
   * @schema BgpPeerV1Beta2Spec#vrf
   */
  readonly vrf?: string;

}

/**
 * Converts an object of type 'BgpPeerV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerV1Beta2Spec(obj: BgpPeerV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bfdProfile': obj.bfdProfile,
    'ebgpMultiHop': obj.ebgpMultiHop,
    'holdTime': obj.holdTime,
    'keepaliveTime': obj.keepaliveTime,
    'myASN': obj.myAsn,
    'nodeSelectors': obj.nodeSelectors?.map(y => toJson_BgpPeerV1Beta2SpecNodeSelectors(y)),
    'password': obj.password,
    'passwordSecret': toJson_BgpPeerV1Beta2SpecPasswordSecret(obj.passwordSecret),
    'peerASN': obj.peerAsn,
    'peerAddress': obj.peerAddress,
    'peerPort': obj.peerPort,
    'routerID': obj.routerId,
    'sourceAddress': obj.sourceAddress,
    'vrf': obj.vrf,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema BgpPeerV1Beta2SpecNodeSelectors
 */
export interface BgpPeerV1Beta2SpecNodeSelectors {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema BgpPeerV1Beta2SpecNodeSelectors#matchExpressions
   */
  readonly matchExpressions?: BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema BgpPeerV1Beta2SpecNodeSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'BgpPeerV1Beta2SpecNodeSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerV1Beta2SpecNodeSelectors(obj: BgpPeerV1Beta2SpecNodeSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * passwordSecret is name of the authentication secret for BGP Peer. the secret must be of type "kubernetes.io/basic-auth", and created in the same namespace as the MetalLB deployment. The password is stored in the secret as the key "password".
 *
 * @schema BgpPeerV1Beta2SpecPasswordSecret
 */
export interface BgpPeerV1Beta2SpecPasswordSecret {
  /**
   * name is unique within a namespace to reference a secret resource.
   *
   * @schema BgpPeerV1Beta2SpecPasswordSecret#name
   */
  readonly name?: string;

  /**
   * namespace defines the space within which the secret name must be unique.
   *
   * @schema BgpPeerV1Beta2SpecPasswordSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'BgpPeerV1Beta2SpecPasswordSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerV1Beta2SpecPasswordSecret(obj: BgpPeerV1Beta2SpecPasswordSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions
 */
export interface BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions(obj: BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

