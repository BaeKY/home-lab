// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AddressPool is the Schema for the addresspools API.
 *
 * @schema AddressPool
 */
export class AddressPool extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AddressPool"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'metallb.io/v1alpha1',
    kind: 'AddressPool',
  }

  /**
   * Renders a Kubernetes manifest for "AddressPool".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AddressPoolProps): any {
    return {
      ...AddressPool.GVK,
      ...toJson_AddressPoolProps(props),
    };
  }

  /**
   * Defines a "AddressPool" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AddressPoolProps) {
    super(scope, id, {
      ...AddressPool.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AddressPool.GVK,
      ...toJson_AddressPoolProps(resolved),
    };
  }
}

/**
 * AddressPool is the Schema for the addresspools API.
 *
 * @schema AddressPool
 */
export interface AddressPoolProps {
  /**
   * @schema AddressPool#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AddressPoolSpec defines the desired state of AddressPool.
   *
   * @schema AddressPool#spec
   */
  readonly spec: AddressPoolSpec;

}

/**
 * Converts an object of type 'AddressPoolProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressPoolProps(obj: AddressPoolProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AddressPoolSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AddressPoolSpec defines the desired state of AddressPool.
 *
 * @schema AddressPoolSpec
 */
export interface AddressPoolSpec {
  /**
   * A list of IP address ranges over which MetalLB has authority. You can list multiple ranges in a single pool, they will all share the same settings. Each range can be either a CIDR prefix, or an explicit start-end range of IPs.
   *
   * @schema AddressPoolSpec#addresses
   */
  readonly addresses: string[];

  /**
   * AutoAssign flag used to prevent MetallB from automatic allocation for a pool.
   *
   * @schema AddressPoolSpec#autoAssign
   */
  readonly autoAssign?: boolean;

  /**
   * When an IP is allocated from this pool, how should it be translated into BGP announcements?
   *
   * @schema AddressPoolSpec#bgpAdvertisements
   */
  readonly bgpAdvertisements?: AddressPoolSpecBgpAdvertisements[];

  /**
   * Protocol can be used to select how the announcement is done.
   *
   * @schema AddressPoolSpec#protocol
   */
  readonly protocol: AddressPoolSpecProtocol;

}

/**
 * Converts an object of type 'AddressPoolSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressPoolSpec(obj: AddressPoolSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addresses': obj.addresses?.map(y => y),
    'autoAssign': obj.autoAssign,
    'bgpAdvertisements': obj.bgpAdvertisements?.map(y => toJson_AddressPoolSpecBgpAdvertisements(y)),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AddressPoolSpecBgpAdvertisements
 */
export interface AddressPoolSpecBgpAdvertisements {
  /**
   * The aggregation-length advertisement option lets you “roll up” the /32s into a larger prefix.
   *
   * @schema AddressPoolSpecBgpAdvertisements#aggregationLength
   */
  readonly aggregationLength?: number;

  /**
   * Optional, defaults to 128 (i.e. no aggregation) if not specified.
   *
   * @schema AddressPoolSpecBgpAdvertisements#aggregationLengthV6
   */
  readonly aggregationLengthV6?: number;

  /**
   * BGP communities
   *
   * @schema AddressPoolSpecBgpAdvertisements#communities
   */
  readonly communities?: string[];

  /**
   * BGP LOCAL_PREF attribute which is used by BGP best path algorithm, Path with higher localpref is preferred over one with lower localpref.
   *
   * @schema AddressPoolSpecBgpAdvertisements#localPref
   */
  readonly localPref?: number;

}

/**
 * Converts an object of type 'AddressPoolSpecBgpAdvertisements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressPoolSpecBgpAdvertisements(obj: AddressPoolSpecBgpAdvertisements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationLength': obj.aggregationLength,
    'aggregationLengthV6': obj.aggregationLengthV6,
    'communities': obj.communities?.map(y => y),
    'localPref': obj.localPref,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocol can be used to select how the announcement is done.
 *
 * @schema AddressPoolSpecProtocol
 */
export enum AddressPoolSpecProtocol {
  /** layer2 */
  LAYER2 = 'layer2',
  /** bgp */
  BGP = 'bgp',
}


/**
 * AddressPool represents a pool of IP addresses that can be allocated to LoadBalancer services. AddressPool is deprecated and being replaced by IPAddressPool.
 *
 * @schema AddressPoolV1Beta1
 */
export class AddressPoolV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AddressPoolV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'metallb.io/v1beta1',
    kind: 'AddressPool',
  }

  /**
   * Renders a Kubernetes manifest for "AddressPoolV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AddressPoolV1Beta1Props): any {
    return {
      ...AddressPoolV1Beta1.GVK,
      ...toJson_AddressPoolV1Beta1Props(props),
    };
  }

  /**
   * Defines a "AddressPoolV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AddressPoolV1Beta1Props) {
    super(scope, id, {
      ...AddressPoolV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AddressPoolV1Beta1.GVK,
      ...toJson_AddressPoolV1Beta1Props(resolved),
    };
  }
}

/**
 * AddressPool represents a pool of IP addresses that can be allocated to LoadBalancer services. AddressPool is deprecated and being replaced by IPAddressPool.
 *
 * @schema AddressPoolV1Beta1
 */
export interface AddressPoolV1Beta1Props {
  /**
   * @schema AddressPoolV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AddressPoolSpec defines the desired state of AddressPool.
   *
   * @schema AddressPoolV1Beta1#spec
   */
  readonly spec: AddressPoolV1Beta1Spec;

}

/**
 * Converts an object of type 'AddressPoolV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressPoolV1Beta1Props(obj: AddressPoolV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AddressPoolV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AddressPoolSpec defines the desired state of AddressPool.
 *
 * @schema AddressPoolV1Beta1Spec
 */
export interface AddressPoolV1Beta1Spec {
  /**
   * A list of IP address ranges over which MetalLB has authority. You can list multiple ranges in a single pool, they will all share the same settings. Each range can be either a CIDR prefix, or an explicit start-end range of IPs.
   *
   * @schema AddressPoolV1Beta1Spec#addresses
   */
  readonly addresses: string[];

  /**
   * AutoAssign flag used to prevent MetallB from automatic allocation for a pool.
   *
   * @schema AddressPoolV1Beta1Spec#autoAssign
   */
  readonly autoAssign?: boolean;

  /**
   * Drives how an IP allocated from this pool should translated into BGP announcements.
   *
   * @schema AddressPoolV1Beta1Spec#bgpAdvertisements
   */
  readonly bgpAdvertisements?: AddressPoolV1Beta1SpecBgpAdvertisements[];

  /**
   * Protocol can be used to select how the announcement is done.
   *
   * @schema AddressPoolV1Beta1Spec#protocol
   */
  readonly protocol: AddressPoolV1Beta1SpecProtocol;

}

/**
 * Converts an object of type 'AddressPoolV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressPoolV1Beta1Spec(obj: AddressPoolV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addresses': obj.addresses?.map(y => y),
    'autoAssign': obj.autoAssign,
    'bgpAdvertisements': obj.bgpAdvertisements?.map(y => toJson_AddressPoolV1Beta1SpecBgpAdvertisements(y)),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AddressPoolV1Beta1SpecBgpAdvertisements
 */
export interface AddressPoolV1Beta1SpecBgpAdvertisements {
  /**
   * The aggregation-length advertisement option lets you “roll up” the /32s into a larger prefix.
   *
   * @schema AddressPoolV1Beta1SpecBgpAdvertisements#aggregationLength
   */
  readonly aggregationLength?: number;

  /**
   * Optional, defaults to 128 (i.e. no aggregation) if not specified.
   *
   * @schema AddressPoolV1Beta1SpecBgpAdvertisements#aggregationLengthV6
   */
  readonly aggregationLengthV6?: number;

  /**
   * BGP communities to be associated with the given advertisement.
   *
   * @schema AddressPoolV1Beta1SpecBgpAdvertisements#communities
   */
  readonly communities?: string[];

  /**
   * BGP LOCAL_PREF attribute which is used by BGP best path algorithm, Path with higher localpref is preferred over one with lower localpref.
   *
   * @schema AddressPoolV1Beta1SpecBgpAdvertisements#localPref
   */
  readonly localPref?: number;

}

/**
 * Converts an object of type 'AddressPoolV1Beta1SpecBgpAdvertisements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressPoolV1Beta1SpecBgpAdvertisements(obj: AddressPoolV1Beta1SpecBgpAdvertisements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationLength': obj.aggregationLength,
    'aggregationLengthV6': obj.aggregationLengthV6,
    'communities': obj.communities?.map(y => y),
    'localPref': obj.localPref,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocol can be used to select how the announcement is done.
 *
 * @schema AddressPoolV1Beta1SpecProtocol
 */
export enum AddressPoolV1Beta1SpecProtocol {
  /** layer2 */
  LAYER2 = 'layer2',
  /** bgp */
  BGP = 'bgp',
}

